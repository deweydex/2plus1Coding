<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG Battle Project - Coding with AI</title>
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
    <nav>
        <div class="nav-container">
            <a href="../index.html" class="site-title">Coding with AI - Learning Activity</a>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="getting-started.html">Getting Started</a></li>
                <li><a href="../projects.html">Projects</a></li>
                <li><a href="../prompting-guide.html">Prompting Guide</a></li>
                <li><a href="../for-teachers.html">For Teachers</a></li>
            </ul>
        </div>
    </nav>

    <main>
        <h1>Project: Turn-Based RPG Battle System</h1>

        <div class="intro">
            <span class="difficulty intermediate">Intermediate</span>
            <p><strong>Estimated Time:</strong> 70-80 minutes | <strong>Language:</strong> Python</p>
        </div>

        <section>
            <h2>Project Overview</h2>
            <p>
                This project guides you through building a turn-based combat system similar to those found in role-playing games. Players and enemies take turns choosing actions, dealing damage, defending, or using special abilities until one side emerges victorious. This type of system is foundational to many games and teaches important concepts about state management, game balance, and strategic decision-making in code.
            </p>

            <p>
                Unlike simpler games where state is relatively static, RPG battles involve complex, changing state: character health fluctuates, temporary status effects apply and expire, abilities go on cooldown, and strategic resources get consumed. Managing this complexity requires careful organization and clear thinking about how different systems interact. The project teaches you to build systems where many pieces work together coherently rather than in isolation.
            </p>

            <p>
                The starter code provides character creation with visual stat displays, immediately showing you characters with health bars and attributes. You will build upon this foundation to create combat mechanics, player choice systems, and strategic depth. The project offers extensive room for creativity through character classes, special abilities, items, status effects, and difficulty balancing.
            </p>
        </section>

        <section>
            <h2>What You Will Learn</h2>
            <p>
                This project develops several advanced programming competencies. You will work extensively with dictionaries as data structures for representing characters with multiple attributes. Understanding when and how to use dictionaries versus other structures is crucial for modeling complex entities in code. Characters have names, health, attack power, defense, and potentially many other attributes. Dictionaries provide a clean way to bundle related data together.
            </p>

            <p>
                The project requires sophisticated state management across multiple systems that interact. Character health changes through combat. Defensive postures affect damage calculation temporarily. Special abilities have usage limits or cooldowns. Status effects modify behavior for limited durations. Managing all these interacting states teaches you to think systematically about program architecture. Poor organization leads to bugs where systems get out of sync; good organization makes the complexity manageable.
            </p>

            <p>
                You will engage directly with game design considerations, not just programming. How much health should characters have? How much damage should attacks deal? Should defending completely block damage or just reduce it? Should special abilities be limited by usage count or cooldown timers? These questions have no single correct answer, but different choices create different player experiences. Testing and iterating to find good balance teaches you that software is not just about correctness but about creating satisfying user experiences.
            </p>

            <p>
                Random number generation plays an important role in creating varied, interesting battles. Pure deterministic combat where the same actions always produce identical results becomes predictable and boring. Adding controlled randomness keeps battles engaging while still being fair. Learning to use randomness appropriately‚Äîenough to create variety but not so much that outcomes feel arbitrary‚Äîis a valuable skill that applies beyond games to simulations, testing, and many other domains.
            </p>
        </section>
        <!-- Version Selector -->
        <div class="version-selector">
            <h2>Choose Your Workflow</h2>
            <div class="version-toggle-buttons">
                <button class="version-btn active" onclick="showVersion('web')" id="web-btn">
                    üåê Web-Based
                    <span class="btn-label">Recommended ‚Ä¢ No Install</span>
                </button>
                <button class="version-btn" onclick="showVersion('desktop')" id="desktop-btn">
                    üíª Desktop
                    <span class="btn-label">Claude Code CLI</span>
                </button>
            </div>
        </div>


        <!-- Planning Resources Section -->
        <section style="background: #e6f4f7; padding: 2rem; border-radius: 8px; margin: 2rem 0;">
            <h2>üìù Before You Start: Planning Your Project</h2>
            <p>
                <strong>Take 10-15 minutes to plan before coding!</strong> Planning saves time and prevents frustration. Use these resources to organize your thoughts:
            </p>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; margin: 1.5rem 0;">
                <div style="background: white; padding: 1.5rem; border-radius: 8px; border-left: 4px solid #006A7C;">
                    <h3 style="margin-top: 0; color: #006A7C;">üìã Planning Template</h3>
                    <p style="margin-bottom: 1rem;">Download our comprehensive planning template with sections for goals, implementation steps, and reflection.</p>
                    <a href="../PROJECT_PLANNING.md" class="btn btn-secondary" download>Download Template</a>
                </div>

                <div style="background: white; padding: 1.5rem; border-radius: 8px; border-left: 4px solid #CC5500;">
                    <h3 style="margin-top: 0; color: #CC5500;">üé® Visual Planning</h3>
                    <p style="margin-bottom: 1rem;">Create flowcharts and diagrams to visualize your program's logic and structure.</p>
                    <a href="https://app.diagrams.net/" class="btn btn-secondary" target="_blank">Open diagrams.net ‚Üí</a>
                </div>

                <div style="background: white; padding: 1.5rem; border-radius: 8px; border-left: 4px solid #006A7C;">
                    <h3 style="margin-top: 0; color: #006A7C;">üìì Enhanced Notebook</h3>
                    <p style="margin-bottom: 1rem;">Fully guided notebook with planning exercises, checkboxes, and reflection prompts built in.</p>
                    <a href="#enhanced-notebook" class="btn btn-secondary">See Enhanced Version ‚Üì</a>
                </div>
            </div>

            <div class="note" style="margin-top: 1.5rem;">
                <strong>Why plan?</strong> Planning helps you break the project into manageable steps, identify potential challenges early, and understand what "done" looks like. Students who plan typically finish faster and with better results!
            </div>
        </section>


        <div id="desktop-content" class="version-content">
        <section>
            <h2>Getting the Starter Code</h2>
            <p>
                Two versions of starter code provide different starting points based on your experience level. The beginner version includes character creation and stat display with visual health bars, giving you immediate visual feedback about character state. The advanced version additionally includes a working attack function with damage calculation, allowing you to focus more on battle flow and strategic elements.
            </p>

            <p>
                Download the appropriate starter code and run it immediately to see what foundation you are building upon. Both versions demonstrate the character display system, showing you how stats are represented and visualized. Understanding this display system is important because it is how players perceive game state.
            </p>

            <div style="display: flex; gap: 1rem; margin: 2rem 0;">
                <a href="../starter-code/rpg_beginner.py" download class="btn">Download Beginner Starter</a>
                <a href="../starter-code/rpg_advanced.py" download class="btn btn-secondary">Download Advanced Starter</a>
            </div>

            <div class="note">
                <strong>First Step:</strong> After downloading, run <code>python rpg_beginner.py</code> (or <code>rpg_advanced.py</code>). The demonstration shows you character creation and stat display. Pay attention to how the health bar visualizes HP percentage and how character attributes are stored in the dictionary structure.
            </div>
        </section>
        </div>

        <div id="web-content" class="version-content active">

        <section>
            <h2>Web-Based Workflow (Alternative)</h2>
            <p>
                If you prefer working entirely in your browser without installing Python locally, you can use Google Colab notebooks combined with Claude.ai for AI assistance. This approach requires no installation and works on any device with internet access. Google Colab provides a free Python environment that runs in the cloud, while Claude.ai offers conversational AI help through a web interface.
            </p>

            <p>
                The web-based workflow uses two browser tabs working together. In one tab, you have Claude.ai open where you can ask questions, request code explanations, and get help solving problems. In the other tab, you have Google Colab where you write and run your actual code. You move between these tabs naturally: ask Claude for help, receive code or explanations, copy relevant code to Colab, test it, and return to Claude with follow-up questions or to report results.
            </p>

            <h3>Opening Your Colab Notebook</h3>
            <p>
                Google Colab notebooks for this project are hosted on GitHub and can be opened directly in Colab with a single click. Choose either the beginner or advanced version based on your experience level. The notebooks contain the same starter code as the downloadable Python files, but formatted as interactive cells that you can run individually.
            </p>

            <div style="display: flex; gap: 1rem; margin: 2rem 0; flex-wrap: wrap;">
                <a href="https://colab.research.google.com/github/deweydex/2plus1Coding/blob/main/colab-notebooks/rpg_beginner.ipynb" class="btn" target="_blank">
                    Open Beginner Notebook in Colab ‚Üí
                </a>
                <a href="https://colab.research.google.com/github/deweydex/2plus1Coding/blob/main/colab-notebooks/rpg_advanced.ipynb" class="btn btn-secondary" target="_blank">
                    Open Advanced Notebook in Colab ‚Üí
                </a>
            </div>

            <p>
                When the notebook opens in Colab, you will see cells containing markdown explanations and Python code. Run the existing code cells to see what your starting point provides. In Colab, you run a cell by clicking the play button on the left side of the cell, or by selecting the cell and pressing Shift+Enter. The output appears directly below the cell, giving you immediate visual feedback about what the code does.
            </p>

            <h3>Working Between Claude.ai and Colab</h3>
            <p>
                Arrange your browser so you can easily switch between Claude.ai and Colab tabs, or use split-screen if your display is large enough. When you encounter a problem or want to add a feature, describe what you want to Claude.ai in the first tab. Be specific about your current code state and what you are trying to accomplish. Claude will respond with explanations, code suggestions, or questions to clarify your intent.
            </p>

            <p>
                When Claude provides code, read through it first to understand what it does. Then copy the relevant portions and paste them into appropriate cells in your Colab notebook. You might add code to an existing cell or create new cells for new functionality. After pasting code, run the cell to test it. If it works as expected, you can proceed to the next feature. If it produces errors or unexpected behavior, return to Claude with specific information about what went wrong.
            </p>

            <p>
                This iterative workflow of asking, implementing, testing, and refining mirrors how professional developers work with AI assistance tools. You maintain control over what code goes into your project while leveraging AI help for implementation details, debugging suggestions, and conceptual explanations. The back-and-forth develops your ability to communicate technical problems clearly and to critically evaluate AI-generated solutions.
            </p>

            <h3>Saving Your Work</h3>
            <p>
                Google Colab notebooks auto-save to your Google Drive periodically, but you should also save manually using File > Save from the Colab menu, especially before closing the tab. If you make a copy of the notebook to your own Drive (File > Save a copy in Drive), you create a personal version that you can modify without affecting the original. This personal copy persists across sessions, allowing you to leave and return to your work later.
            </p>

            <p>
                When you finish working, you can download your completed notebook using File > Download > Download .ipynb to save it locally. You can also download just the Python code using File > Download > Download .py, which extracts code cells into a standalone Python file similar to the original starter code format. This flexibility allows you to work in Colab during development and export results in whatever format you need.
            </p>

            <div class="note">
                <strong>New to this workflow?</strong> Review the <a href="../getting-started-web.html">Web-Based Getting Started Guide</a> for detailed setup instructions for Claude.ai and Google Colab, including screenshots and troubleshooting tips.
            </div>
        </section>

                </div>
<section>
            <h2>Phase 1: Planning Your Build (15 minutes)</h2>
            <p>
                Before writing combat code, think carefully about how battles should flow and what information needs to be tracked. A turn-based battle has clear structure: display current state, get player choice, execute player action, check for victory, execute enemy action, check for victory, repeat. This structure provides a framework to build upon, but many details need to be decided.
            </p>

            <p>
                Consider what actions should be available to players. At minimum, attacking makes sense. Defending might reduce incoming damage for one turn. Special abilities provide strategic depth but need constraints to prevent overuse. Items could heal or provide buffs but require an inventory system. Start simple with attack and defend, then add complexity once the basics work. This incremental approach prevents overwhelming yourself with too many interconnected systems at once.
            </p>

            <h3>Understanding Character State</h3>
            <p>
                The starter code represents characters as dictionaries with keys for name, hp, max_hp, attack, and defense. This structure is extensible: you can add new keys as needed without restructuring existing code. If you want to add a character's level, just include a level key. If you want to track status effects, add a status key containing a list or set. This flexibility makes dictionaries excellent for representing game entities that may grow more complex over time.
            </p>

            <p>
                Think about what happens to character state during battle. Health decreases when taking damage and potentially increases when healing. Temporary defense boosts apply and expire. Special abilities get used and become unavailable until certain conditions reset them. Managing these state transitions consistently prevents bugs where game state becomes incoherent. Writing down what can change and under what conditions helps you design clear, maintainable code.
            </p>

            <h3>Damage Calculation Considerations</h3>
            <p>
                How should damage be calculated? A simple approach subtracts the defender's defense from the attacker's attack to get damage dealt. This works but is entirely deterministic. Adding random variation makes each exchange feel different even with identical stats. The starter code includes randomness in its damage calculation, but you should understand the tradeoffs. Too much randomness makes battles feel arbitrary. Too little makes them predictable. Finding the right balance is part of game design.
            </p>

            <p>
                Should there be minimum damage? If defense exceeds attack, deterministic calculation produces zero or negative damage. Guaranteeing at least 1 damage ensures battles progress even with stat imbalances, though it affects how defense works at high values. These seemingly small decisions compound to create the overall combat feel.
            </p>
        </section>

        <section>
            <h2>Phase 2: Building the Core Battle (35 minutes)</h2>
            <p>
                Build your battle system incrementally, starting with the simplest possible combat and gradually adding features. The starter code provides the foundation; your task is to create a working game loop with player interaction and victory conditions.
            </p>

            <h3>Implementing Combat Actions</h3>
            <p>
                Your first task is to create or complete the attack function that handles one character damaging another. This function calculates damage based on attacker and defender stats, reduces the defender's health, and returns information about what happened. The calculation might include the base attack value, the defender's defense, and some random variation to keep battles interesting. Ensure health never goes below zero, as negative health can cause confusing display issues.
            </p>

            <p>
                When you have basic attacking working, add defensive postures. A defending action might temporarily increase a character's defense, reduce damage taken by a percentage, or regenerate a small amount of health. Different implementations create different strategic dynamics. Temporary defense increases reward planning ahead. Percentage-based reduction scales with damage received. Health regeneration provides sustain over long battles. Experiment to find what creates interesting decisions.
            </p>

            <h3>Player Choice System</h3>
            <p>
                Players need to choose actions each turn. Create a function that displays available actions, gets player input, validates the choice, and returns the selected action. The user interface does not need to be elaborate, but it should be clear. Numbering options (1: Attack, 2: Defend) works well. Validate input to handle cases where players enter invalid numbers, letters, or nothing at all. Robust input handling prevents frustrating crashes during gameplay.
            </p>

            <p>
                As you add more action types, this choice system expands naturally. Each new action needs an entry in the menu and a handler in the execution code. Keeping this system organized becomes important as complexity grows. Consider using a dictionary to map choice numbers to action functions, making it easy to add new actions without extensive conditional logic.
            </p>

            <h3>Enemy Decision Making</h3>
            <p>
                Enemy actions need logic to decide what to do each turn. Start with simple approaches: always attack, or choose randomly between attacking and defending. Simple AI works fine for initial testing and can provide adequate challenge if stat balance is good. As you test, you might notice that smarter enemy behavior creates more interesting battles. An enemy that defends when low on health forces players to decide whether to attack through the defense or wait. An enemy that uses special abilities strategically creates tension.
            </p>

            <p>
                Implementing enemy AI teaches you about conditional logic and decision trees. If the enemy's health is below a threshold, defend or use a healing ability. If the player has buffed their attack, the enemy might defend more. These conditional behaviors make enemies feel less mechanical and battles more dynamic. You do not need sophisticated AI for a good experience, just enough variety that player decisions matter.
            </p>

            <h3>The Battle Loop</h3>
            <p>
                With actions implemented, create the main battle loop that orchestrates turns until victory or defeat. Each iteration displays current state so players understand the situation. The player chooses and executes their action. The game checks if the enemy has been defeated; if so, the player wins and the loop ends. If the enemy survives, they take their turn. The game checks if the player has been defeated; if so, the player loses and the loop ends. Otherwise, the loop continues for another turn.
            </p>

            <p>
                This structure is straightforward but effective. Displaying state at the start of each turn ensures players have current information when making decisions. Checking victory conditions after each action means the battle ends immediately when appropriate rather than continuing for unnecessary actions. Clear victory and defeat messages provide closure and reinforce what happened.
            </p>

            <h3>Victory and Defeat Conditions</h3>
            <p>
                The basic condition for victory is reducing the enemy's health to zero. The basic condition for defeat is the player's health reaching zero. These conditions are simple to check but think about edge cases. Can both characters reach zero health simultaneously? How should that be handled? You might declare it a draw, or give victory to whoever dealt the finishing blow first. Either works, but you need to decide and implement consistently.
            </p>

            <p>
                Consider whether there should be other victory conditions. A turn limit creates urgency and prevents infinite battles if damage output is very low. A flee option lets players escape losing battles but might be considered a loss or might allow retrying with different strategy. These variations add depth but require additional implementation and testing.
            </p>
        </section>

        <section>
            <h2>Phase 3: Enhancements and Strategic Depth (20 minutes)</h2>
            <p>
                With core combat working, enhancements add strategic depth, variety, and replayability. Choose enhancements that interest you and teach concepts you want to explore. Different enhancements lead down different paths of increasing complexity.
            </p>

            <h3>Special Abilities</h3>
            <p>
                Special abilities give players powerful options that cannot be used every turn. A special attack might deal double damage but be usable only once per battle. A healing ability might restore health but have a cooldown of several turns. A buff ability might temporarily increase attack power. These abilities create strategic decisions: when is the right time to use a limited resource? Should you save your special attack for when the enemy is low, or use it early to gain advantage?
            </p>

            <p>
                Implementing special abilities teaches you about tracking usage constraints. One-time abilities need a boolean flag indicating whether they have been used. Cooldown-based abilities need a counter that decrements each turn until reaching zero, at which point the ability becomes available again. Resource-based abilities need a resource pool (mana, energy, stamina) that depletes with use and regenerates over time. Different constraint systems create different gameplay dynamics.
            </p>

            <h3>Character Classes and Variety</h3>
            <p>
                Allow players to choose from multiple character classes with different stat distributions and abilities. A warrior might have high health and attack but no healing. A mage might have lower health but powerful special abilities. A rogue might have moderate stats but abilities that manipulate turn order or inflict status effects. Different classes create different playstyles and encourage replaying with new approaches.
            </p>

            <p>
                Implementing character classes extends your character creation system. You might create template functions for each class that return appropriately initialized characters, or use a class selection system that modifies base stats. Different implementations have different extensibility tradeoffs. Think about how easy it would be to add a fourth class to your system.
            </p>

            <h3>Status Effects</h3>
            <p>
                Status effects modify character behavior temporarily. Poison deals damage over time. Stun prevents taking actions. Buffs increase stats for several turns. Debuffs decrease them. Status effects add tactical complexity: do you use an ability that deals damage now, or one that applies poison for sustained damage? Do you attack an enemy who is stunned, or set up for an even bigger next turn?
            </p>

            <p>
                Implementing status effects requires tracking what effects are active, what they do, and when they expire. One approach stores a list of active effects with each character, where each effect has a type, a magnitude, and a remaining duration. Each turn, effects trigger their behavior (damage for poison, stat changes for buffs), then decrement duration, removing effects that expire. This system is flexible but requires careful testing to ensure effects apply correctly and clean up properly.
            </p>

            <h3>Item Systems</h3>
            <p>
                Items provide consumable benefits during battle. Healing potions restore health. Attack buffs temporarily increase damage. Defensive items reduce incoming damage. Item systems add resource management: players have limited items and must decide when to use them versus saving them for later emergencies. This creates interesting tension between using resources now to win this battle versus conserving them for tougher battles ahead.
            </p>

            <p>
                Implementing an item system requires inventory management. A simple approach uses a dictionary mapping item names to quantities. Using an item reduces its quantity. Running out of an item removes it from available options. More complex systems might include item effects with varying durations, items that affect enemies rather than the player, or items that can only be used under certain conditions.
            </p>

            <h3>Multiple Battles and Progression</h3>
            <p>
                String multiple battles together where the player's health carries over between fights. This creates a survival challenge: conserve resources and health across multiple encounters. Defeat ends the run; victory means continuing to the next, tougher enemy. This gauntlet structure creates rising tension and makes resource management crucial. Healing becomes more valuable when health does not fully restore between battles.
            </p>

            <p>
                You might add progression systems where players gain experience or level up between battles, permanently improving stats. This provides a sense of growth and makes later battles manageable despite tougher enemies. Implementing progression teaches you about persistent state across multiple game sessions and how to balance increasing power against increasing challenge.
            </p>
        </section>

        <section>
            <h2>Game Balance and Playtesting</h2>
            <p>
                Balance is crucial for creating satisfying gameplay. If the player is too powerful, battles become trivial. If enemies are too strong, battles become impossible and frustrating. Good balance creates challenge that feels fair and winnable through good decision-making. Achieving this balance requires testing, iteration, and willingness to adjust numbers based on how the game actually feels.
            </p>

            <p>
                Start with rough estimates for stats: maybe the player has 100 HP and 15 attack, while a basic enemy has 50 HP and 10 attack. Play several battles. Do they feel too easy? Increase enemy stats. Too hard? Decrease them or increase player stats. Does one strategy dominate? Adjust costs or cooldowns to encourage variety. Balance is an iterative process of testing, identifying problems, making adjustments, and testing again.
            </p>

            <p>
                As you add complexity, balance becomes more intricate. Multiple character classes need to feel equally viable. Different abilities should each have situations where they are the right choice. Status effects should be powerful enough to be worth using but not so strong they trivialize encounters. Finding this balance teaches you to think about systems holistically rather than in isolation. A small change to one ability can ripple through the entire combat system.
            </p>
        </section>

        <section>
            <h2>Testing and Debugging</h2>
            <p>
                RPG battle systems have many interacting pieces, making bugs potentially subtle. Test systematically to ensure everything works correctly. Play battles where the player wins, loses, and achieves any special conditions. Test every ability and item. Try unusual combinations of actions to see if anything breaks. This comprehensive testing reveals edge cases that casual play might miss.
            </p>

            <p>
                When debugging, isolate which system is malfunctioning. If damage seems wrong, add print statements showing the calculation step by step. If status effects do not expire correctly, display active effects and their remaining durations each turn. If game state becomes inconsistent, verify that all code paths update state correctly. Systematic isolation helps you locate problems efficiently even in complex systems.
            </p>

            <h3>Common Issues</h3>
            <p>
                Health going negative causes display problems and can break victory detection if you check for exactly zero. Always enforce minimum health of zero after damage. Status effects that do not clean up properly can keep affecting characters after they should have expired. Ensure effects decrement duration and remove themselves appropriately. Player abilities that can be used after they should be unavailable indicate constraint tracking is not working; verify that usage flags update or cooldowns decrement each turn.
            </p>
        </section>

        <section>
            <h2>Creative Directions and Extensions</h2>
            <p>
                Your battle system provides a rich foundation for exploring game design, AI programming, and complex data structures. These extensions let you dive deeper into areas that interest you.
            </p>

            <h3>Ideas to Explore</h3>
            <p>
                <strong>Character Classes:</strong> Design unique classes (warrior, mage, rogue) with distinct stat distributions, special abilities, and playstyles.
            </p>

            <p>
                <strong>Equipment and Inventory:</strong> Add weapons, armor, and items that modify stats or grant abilities. Implement an inventory system where players find and equip gear.
            </p>

            <p>
                <strong>Status Effects:</strong> Implement poison (damage over time), stun (skip turns), buffs (temporary stat boosts), or debuffs (weakened defense).
            </p>

            <p>
                <strong>Enemy AI:</strong> Create different AI strategies - aggressive enemies that always attack, defensive enemies that heal when low on health, or tactical enemies that target the weakest party member.
            </p>

            <p>
                <strong>Party System:</strong> Manage multiple player characters, allowing tactical decisions about which character acts and coordinating abilities between party members.
            </p>

            <p>
                <strong>Experience and Leveling:</strong> Award experience points for victories, implement leveling up with stat increases, and create a sense of progression across multiple battles.
            </p>

            <p>
                <strong>Story Campaign:</strong> Design a sequence of battles with increasing difficulty, narrative context between fights, and boss battles with unique mechanics.
            </p>

            <p>
                Focus on extensions that teach you new concepts. Each addition - from AI decision-making to inventory management to progression systems - represents real game development challenges that apply beyond this project.
            </p>
        </section>

        <section>
            <h2>Reflection and Extension</h2>
            <p>
                After completing your battle system, reflect on what you learned about managing complex, interacting systems. This kind of systems thinking applies far beyond games to any program with multiple components that must work together coherently. Consider how you organized your code to handle this complexity. Did you use functions to separate concerns? Did you keep related data together? Did you make it easy to add new features without rewriting existing code?
            </p>

            <p>
                Think about the design decisions you made and how they affected gameplay. Which abilities felt most satisfying to use? Which battles felt most balanced? What would you change if you were starting over? This critical reflection helps you develop design instincts that improve with each project.
            </p>

            <p>
                Consider how you might extend this project further. Could you add an exploration system where players navigate a world and trigger battles at certain locations? Could you implement a save system so players can continue later? Could you create an equipment system where players find weapons and armor that modify stats? Each extension builds on your working foundation, teaching new concepts while reinforcing what you have learned.
            </p>
        </section>

        <section>
            <h2>Resources and Further Learning</h2>
            <p>
                To deepen your understanding of game design, systems programming, and the concepts used in this project, several educational resources provide valuable perspectives with strong pedagogical grounding.
            </p>

            <p>
                <strong>Game Programming Patterns</strong> by Robert Nystrom provides accessible explanations of design patterns commonly used in game development. Available free online at <a href="https://gameprogrammingpatterns.com/">gameprogrammingpatterns.com</a>.
            </p>

            <p>
                <strong>Python Dictionaries Documentation</strong> at <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">docs.python.org</a> covers the data structure central to character representation in this project.
            </p>

            <p>
                <strong>Sebastian Lague's YouTube Channel</strong> offers clear visual explanations of game programming concepts and algorithms. Find these at <a href="https://www.youtube.com/c/SebastianLague">youtube.com/c/SebastianLague</a>.
            </p>

            <p>
                <strong>The Art of Game Design: A Book of Lenses</strong> by Jesse Schell provides frameworks for thinking about game balance and player experience, applicable to projects like this RPG battle system.
            </p>
        </section>

        <section class="callout">
            <h3>Need Help?</h3>
            <p>
                If you encounter difficulties, review the <a href="../prompting-guide.html">Prompting Guide</a> for strategies on asking effective questions. RPG systems involve many moving parts, so breaking problems into smaller pieces helps. If something is not working, test each component individually before testing them together. Isolate the problem, then ask Claude for help with that specific piece rather than the entire system at once.
            </p>
        </section>
    </main>

    <footer>
        <p>Coding with AI - Learning Activity | QQI Level 5/6 Computer Science</p>
        <p>Licensed under MIT License | <a href="https://github.com/deweydex/2plus1Coding">View on GitHub</a></p>
    </footer>

    <script>
        function showVersion(version) {
            // Hide all content
            document.querySelectorAll('.version-content').forEach(el => {
                el.classList.remove('active');
            });
            
            // Remove active from all buttons
            document.querySelectorAll('.version-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected content
            document.getElementById(version + '-content').classList.add('active');
            document.getElementById(version + '-btn').classList.add('active');
        }
    </script>

</body>
</html>
