<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic-Tac-Toe Project - Claude Code Learning Activity</title>
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
    <nav>
        <div class="nav-container">
            <a href="../index.html" class="site-title">Claude Code Learning Activity</a>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../getting-started.html">Getting Started</a></li>
                <li class="dropdown">
                    <a href="#projects">Projects ▾</a>
                    <div class="dropdown-content">
                        <a href="tic-tac-toe.html">Tic-Tac-Toe</a>
                        <a href="word-guessing.html">Word Guessing</a>
                        <a href="rpg-battle.html">RPG Battle</a>
                        <a href="image-processing.html">Image Processing</a>
                        <a href="machine-learning.html">Machine Learning</a>
                    </div>
                </li>
                <li><a href="../prompting-guide.html">Prompting Guide</a></li>
                <li><a href="../for-teachers.html">For Teachers</a></li>
            </ul>
        </div>
    </nav>

    <main>
        <h1>Project: Tic-Tac-Toe Game</h1>

        <div class="intro">
            <span class="difficulty beginner">Beginner Friendly</span>
            <p><strong>Estimated Time:</strong> 60-70 minutes | <strong>Language:</strong> Python</p>
        </div>

        <section>
            <h2>Project Overview</h2>
            <p>
                This project guides you through building a two-player tic-tac-toe game that runs in the terminal. Tic-tac-toe is an ideal first project for learning programming because everyone already understands the rules, the game state is easy to visualize, and the logic can be broken down into clear, manageable steps. The project teaches fundamental programming concepts including data structures, functions, loops, and conditional logic, all within a context that makes immediate intuitive sense.
            </p>

            <p>
                You will start with functional starter code that displays a game board, giving you something visual and working from the first moment. Your task is to incrementally add features: player input, turn alternation, win detection, and enhancements of your choosing. This incremental approach ensures you understand each component before moving to the next, building both your code and your understanding simultaneously.
            </p>
        </section>

        <section>
            <h2>What You Will Learn</h2>
            <p>
                Through building this game, you will develop several key programming competencies. You will learn to represent game state using data structures, specifically lists for storing the board positions. You will practice designing and implementing functions that each handle a specific responsibility, learning how to break complex problems into smaller, manageable pieces. You will work with loops to create a game that continues until a win condition is met, and you will implement conditional logic to check for various game states.
            </p>

            <p>
                Beyond specific Python syntax, this project develops problem-solving approaches that transfer to other programming contexts. You will learn to think about edge cases: what happens if a player enters invalid input? How do you check all possible winning conditions efficiently? How do you structure code so it is easy to understand and modify later? These habits of thought matter more than memorizing particular code patterns.
            </p>

            <p>
                Working with Claude Code adds another layer of learning. You will practice articulating what you want in clear, specific language. You will develop the skill of reading and understanding code you did not write yourself. You will learn to test systematically and debug methodically. These skills are essential for modern software development, where you often work with code written by others or generated by tools.
            </p>
        </section>

        <section>
            <h2>Getting the Starter Code</h2>
            <p>
                Two versions of starter code are available, allowing you to choose a starting point that matches your experience level. The beginner version provides a working board display function and basic structure, giving you immediate visual feedback when you run the program. The advanced version includes board display and player input handling, allowing you to focus more on game logic and enhancements.
            </p>

            <p>
                Download the appropriate starter code and save it in your project directory. Run the file immediately to see what you are starting with. Understanding your starting point is crucial before you begin adding features.
            </p>

            <div style="display: flex; gap: 1rem; margin: 2rem 0;">
                <a href="../starter-code/tictactoe_beginner.py" download class="btn">Download Beginner Starter</a>
                <a href="../starter-code/tictactoe_advanced.py" download class="btn btn-secondary">Download Advanced Starter</a>
            </div>

            <div class="note">
                <strong>First Step:</strong> After downloading, navigate to your project directory in the terminal and run <code>python tictactoe_beginner.py</code> (or <code>tictactoe_advanced.py</code>). Seeing the starter code in action helps you understand what foundation you are building upon.
            </div>
        </section>

        <section>
            <h2>Web-Based Workflow (Alternative)</h2>
            <p>
                If you prefer working entirely in your browser without installing Python locally, you can use Google Colab notebooks combined with Claude.ai for AI assistance. This approach requires no installation and works on any device with internet access. Google Colab provides a free Python environment that runs in the cloud, while Claude.ai offers conversational AI help through a web interface.
            </p>

            <p>
                The web-based workflow uses two browser tabs working together. In one tab, you have Claude.ai open where you can ask questions, request code explanations, and get help solving problems. In the other tab, you have Google Colab where you write and run your actual code. You move between these tabs naturally: ask Claude for help, receive code or explanations, copy relevant code to Colab, test it, and return to Claude with follow-up questions or to report results.
            </p>

            <h3>Opening Your Colab Notebook</h3>
            <p>
                Google Colab notebooks for this project are hosted on GitHub and can be opened directly in Colab with a single click. Choose either the beginner or advanced version based on your experience level. The notebooks contain the same starter code as the downloadable Python files, but formatted as interactive cells that you can run individually.
            </p>

            <div style="display: flex; gap: 1rem; margin: 2rem 0; flex-wrap: wrap;">
                <a href="https://colab.research.google.com/github/deweydex/2plus1Coding/blob/main/colab-notebooks/tictactoe_beginner.ipynb" class="btn" target="_blank">
                    Open Beginner Notebook in Colab →
                </a>
                <a href="https://colab.research.google.com/github/deweydex/2plus1Coding/blob/main/colab-notebooks/tictactoe_advanced.ipynb" class="btn btn-secondary" target="_blank">
                    Open Advanced Notebook in Colab →
                </a>
            </div>

            <p>
                When the notebook opens in Colab, you will see cells containing markdown explanations and Python code. Run the existing code cells to see what your starting point provides. In Colab, you run a cell by clicking the play button on the left side of the cell, or by selecting the cell and pressing Shift+Enter. The output appears directly below the cell, giving you immediate visual feedback about what the code does.
            </p>

            <h3>Working Between Claude.ai and Colab</h3>
            <p>
                Arrange your browser so you can easily switch between Claude.ai and Colab tabs, or use split-screen if your display is large enough. When you encounter a problem or want to add a feature, describe what you want to Claude.ai in the first tab. Be specific about your current code state and what you are trying to accomplish. Claude will respond with explanations, code suggestions, or questions to clarify your intent.
            </p>

            <p>
                When Claude provides code, read through it first to understand what it does. Then copy the relevant portions and paste them into appropriate cells in your Colab notebook. You might add code to an existing cell or create new cells for new functionality. After pasting code, run the cell to test it. If it works as expected, you can proceed to the next feature. If it produces errors or unexpected behavior, return to Claude with specific information about what went wrong.
            </p>

            <p>
                This iterative workflow of asking, implementing, testing, and refining mirrors how professional developers work with AI assistance tools. You maintain control over what code goes into your project while leveraging AI help for implementation details, debugging suggestions, and conceptual explanations. The back-and-forth develops your ability to communicate technical problems clearly and to critically evaluate AI-generated solutions.
            </p>

            <h3>Saving Your Work</h3>
            <p>
                Google Colab notebooks auto-save to your Google Drive periodically, but you should also save manually using File > Save from the Colab menu, especially before closing the tab. If you make a copy of the notebook to your own Drive (File > Save a copy in Drive), you create a personal version that you can modify without affecting the original. This personal copy persists across sessions, allowing you to leave and return to your work later.
            </p>

            <p>
                When you finish working, you can download your completed notebook using File > Download > Download .ipynb to save it locally. You can also download just the Python code using File > Download > Download .py, which extracts code cells into a standalone Python file similar to the original starter code format. This flexibility allows you to work in Colab during development and export results in whatever format you need.
            </p>

            <div class="note">
                <strong>New to this workflow?</strong> Review the <a href="../getting-started-web.html">Web-Based Getting Started Guide</a> for detailed setup instructions for Claude.ai and Google Colab, including screenshots and troubleshooting tips.
            </div>
        </section>

        <section>
            <h2>Phase 1: Planning Your Build (15 minutes)</h2>
            <p>
                Before writing any new code, take time to understand the problem you are solving and plan your approach. This planning phase is not wasted time; it prevents confusion and false starts that would cost more time later. Good planning also helps you communicate more effectively with Claude Code because you have a clear vision of what you are trying to build.
            </p>

            <p>
                Start by examining the starter code carefully. What data structure represents the board? How does the display function work? What do you need to add to make this a playable game? Discuss these questions with your partner if you are working in pairs. Sketch out on paper what the flow of the game should be: players take turns, each turn involves getting input and updating the board, after each move you check for a winner or tie, and the game ends when someone wins or the board fills.
            </p>

            <h3>Key Questions to Answer</h3>
            <p>
                Consider how you will represent different pieces of information. The starter code uses a list of strings for the board, where each element is either a number (showing the position) or a player symbol (X or O). How will you check if a position is already taken? How will you switch between players? What exactly constitutes a win?
            </p>

            <p>
                Think about the minimum viable product: the simplest version that could work. This is not a game with sophisticated AI or elaborate graphics. It is two humans taking turns at the same computer, entering numbers to indicate their moves, with the game detecting when someone wins. Everything else is enhancement. Keeping your initial scope modest ensures you finish with a working product rather than an ambitious, incomplete one.
            </p>

            <p>
                Write down the order you will build features. A sensible sequence might be: first, add the ability for one player to make one move; then add turn alternation so players take turns; then add win detection; then handle tie games; finally, add enhancements like input validation and play-again functionality. This sequence ensures each step builds on working code from the previous step.
            </p>
        </section>

        <section>
            <h2>Phase 2: Building the Core Game (35 minutes)</h2>
            <p>
                With your plan in place, begin building incrementally using Claude Code. The key principle is to add one feature at a time, test it thoroughly, and make sure you understand it before moving to the next feature. This discipline feels slow at first but actually accelerates development by preventing the confusion that comes from changing too much at once.
            </p>

            <h3>Adding Player Moves</h3>
            <p>
                Your first task is to allow a player to make a move. You need a function that takes a position and a player symbol and updates the board. Consider how to convert from the position the user enters (numbers 1-9) to the list indices Python uses (0-8). The transformation is straightforward but easy to forget: list index equals position minus one.
            </p>

            <p>
                When you ask Claude Code to add this functionality, be specific about what you want. A good prompt might be: "Add a function called make_move that takes the board, a position from 1 to 9, and a player symbol (X or O), then updates the board at that position. Then modify the main function to let one player make one move and display the updated board." This specificity helps Claude generate appropriate code rather than guessing at your intent.
            </p>

            <p>
                After Claude generates the code, read it carefully before running it. Can you explain what each line does? If you see something unfamiliar, ask Claude to explain it. Once you understand the code, test it. Run your program, enter a position, and verify that the board updates correctly. Try different positions to make sure they all work. This testing confirms that your understanding matches reality.
            </p>

            <h3>Alternating Turns</h3>
            <p>
                Once single moves work, add turn alternation. You need to track whose turn it is and switch players after each move. There are multiple ways to accomplish this. You could use an if-else statement that switches between X and O. You could use a ternary expression for more compact code. You could even use a list of players and alternate indices. Different approaches have different tradeoffs in terms of readability and flexibility.
            </p>

            <p>
                Ask Claude to implement this, but also ask for an explanation of the approach chosen. Understanding why a particular solution works helps you make similar decisions in future projects. A loop structure likely emerges here: you repeat the process of getting a move, making the move, displaying the board, and switching players until some condition is met.
            </p>

            <p>
                Test thoroughly at this stage. Play through several turns. Do players alternate correctly? Does the board update after each move? Does the display show current game state accurately? Testing may feel tedious, but it ensures the foundation is solid before you add more complex features.
            </p>

            <h3>Win Detection</h3>
            <p>
                Detecting a win is algorithmically the most interesting part of tic-tac-toe. There are eight ways to win: three rows, three columns, and two diagonals. You need a function that checks all eight conditions and determines if any constitute a win for X or O. This is an excellent opportunity to think about how to write clear, maintainable code for checking multiple similar conditions.
            </p>

            <p>
                One approach is to explicitly check each winning combination with separate if statements. This is verbose but extremely clear. Another approach is to define all winning combinations in a data structure (like a list of lists) and loop through them, checking each one. This is more compact and easier to modify if the board size changed, but slightly less obvious on first reading. Ask Claude to show you one approach, then perhaps ask what alternative approaches exist and why you might choose one over another.
            </p>

            <p>
                When testing win detection, be systematic. Test that it recognizes a win in the top row. Test all three rows. Test columns. Test both diagonals. Test that it does not falsely report a win when the game is still ongoing. Thorough testing here prevents mysterious bugs later where the game ends at the wrong time or fails to recognize a legitimate win.
            </p>

            <h3>Tie Detection and Game Flow</h3>
            <p>
                The game should also detect tie situations where the board is full but no one has won. This requires checking if all positions have been filled with X or O rather than the original position numbers. Once you can detect both wins and ties, integrate these checks into your game loop so the game ends at the appropriate time with an appropriate message.
            </p>

            <p>
                At this point, you should have a fully playable game. Two players can take turns, the game detects wins and ties, and it ends gracefully. Test the complete game flow several times. Play games where X wins, where O wins, and where the game ties. Verify that all messages are appropriate and that the game exits properly rather than continuing or crashing.
            </p>
        </section>

        <section>
            <h2>Phase 3: Enhancements (20 minutes)</h2>
            <p>
                With core functionality working, you can add enhancements that improve the user experience or extend the game's capabilities. Choose enhancements that interest you rather than trying to implement everything. Part of being a developer is deciding what features add the most value given limited time.
            </p>

            <h3>Input Validation</h3>
            <p>
                Currently, your game may not handle invalid input gracefully. What happens if a player enters a letter instead of a number? What if they enter 0 or 15? What if they try to play in a square that is already occupied? Input validation makes your program robust against these cases. Rather than crashing or behaving strangely, the program should explain the problem and ask for valid input.
            </p>

            <p>
                Implementing input validation teaches you about exception handling and defensive programming. You learn to anticipate what might go wrong and handle those cases explicitly. This mindset is crucial for writing reliable software.
            </p>

            <h3>Play Again Functionality</h3>
            <p>
                After a game ends, ask players if they want another round. If yes, reset the board and start a new game. If no, exit gracefully. This requires thinking about program structure: do you wrap your game logic in another loop? Do you put the initialization code in a function you can call repeatedly? Different structural choices have different implications for code organization.
            </p>

            <h3>Score Tracking</h3>
            <p>
                Track how many games X has won, how many O has won, and how many have tied. Display these statistics after each game. This introduces the concept of persistent state that survives across multiple game rounds. You need variables that exist outside the individual game loop and update each time a game concludes.
            </p>

            <h3>Improved Display</h3>
            <p>
                The basic board display works but is somewhat plain. You might enhance it with clearer borders, better spacing, or even terminal colors if you learn how to use ANSI escape codes or a library like colorama. Visual polish makes programs more satisfying to use, and learning to improve user interfaces is a valuable skill.
            </p>

            <h3>Computer Opponent</h3>
            <p>
                For a more ambitious enhancement, add a single-player mode where one player competes against the computer. Start with the computer making random valid moves. This is simpler than it sounds: choose a random position from the list of available positions. Once random moves work, you could explore making the computer smarter: can it block the player from winning? Can it recognize when it can win in one move?
            </p>

            <p>
                Building game AI, even simple AI, introduces algorithmic thinking. You are encoding strategy as code: if this condition holds, take that action. This is the foundation of all game AI and decision-making systems.
            </p>
        </section>

        <section>
            <h2>Testing and Debugging</h2>
            <p>
                Throughout development, testing is your primary tool for verifying correctness. When something does not work as expected, methodical debugging helps you identify and fix problems efficiently. Read error messages carefully; they tell you what type of error occurred and on which line. Use print statements to inspect variable values at different points in your program. Explain the problem to your partner (or even to yourself aloud); often the act of explaining reveals the issue.
            </p>

            <p>
                When asking Claude Code for debugging help, provide specific information about what went wrong. Instead of "it does not work," say "when I enter position 5, I expected the center square to show X, but I get an IndexError on line 23." This specificity allows Claude to help much more effectively.
            </p>

            <h3>Common Issues and Solutions</h3>
            <p>
                Index errors often arise from confusion between user-facing position numbers (1-9) and zero-based list indices (0-8). Double-check that you are converting correctly. Logic errors in win detection typically come from checking the wrong board positions or incorrect boolean logic in combining conditions. Test each winning condition individually to isolate which one is not working. If the game continues after someone wins, ensure you are actually breaking out of or ending the game loop when a win is detected.
            </p>
        </section>

        <section>
            <h2>Reflection and Next Steps</h2>
            <p>
                When your game works, take time to reflect on what you built and how you built it. Can you explain to someone else how your win detection algorithm works? Could you modify the code to use a 4x4 board instead? What was the most challenging part, and how did you overcome it? This reflection solidifies learning and helps you identify patterns you can apply to future projects.
            </p>

            <p>
                Consider reviewing your code critically. Is it well-organized? Could someone else understand it? Are there repeated sections that could be extracted into functions? This kind of reflective review develops your code quality instincts beyond just making things work.
            </p>

            <p>
                If you want to continue developing your skills, try tackling another project from this collection. Each project teaches different concepts and patterns. Building multiple projects helps you recognize which patterns apply across different problem domains.
            </p>
        </section>

        <section>
            <h2>Resources and Further Learning</h2>
            <p>
                If you want to deepen your understanding of the programming concepts used in this project, several high-quality educational resources are available. These materials provide clear explanations with minimal prerequisites and strong pedagogical foundations.
            </p>

            <p>
                <strong>Python Documentation</strong> at <a href="https://docs.python.org/3/">docs.python.org/3</a> provides comprehensive reference material for Python's built-in data structures and control flow constructs used in this project.
            </p>

            <p>
                <strong>Real Python</strong> offers in-depth tutorials on Python fundamentals, including articles on lists, loops, and functions. Available at <a href="https://realpython.com/">realpython.com</a>.
            </p>

            <p>
                <strong>Computerphile</strong> provides accessible video explanations of computer science concepts, including algorithms and game programming. Find these at <a href="https://www.youtube.com/user/Computerphile">youtube.com/user/Computerphile</a>.
            </p>
        </section>

        <section class="callout">
            <h3>Need Help?</h3>
            <p>
                If you get stuck, refer back to the <a href="../prompting-guide.html">Prompting Guide</a> for strategies on asking effective questions. Remember that struggling with a problem is part of learning. If you are working in pairs, discuss the problem together before asking Claude or a facilitator. Often the act of explaining the problem to another person helps you see the solution.
            </p>
        </section>
    </main>

    <footer>
        <p>Claude Code Learning Activity | QQI Level 5/6 Computer Science</p>
        <p>Licensed under MIT License | <a href="https://github.com/deweydex/2plus1Coding">View on GitHub</a></p>
    </footer>
</body>
</html>
